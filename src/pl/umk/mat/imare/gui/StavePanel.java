/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * StavePanel.java
 *
 * Created on Feb 6, 2010, 9:19:37 AM
 */
package pl.umk.mat.imare.gui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.image.BufferedImageOp;
import java.awt.image.BufferedImage;
import java.awt.image.RescaleOp;
import java.io.IOException;
import java.util.ArrayList;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import pl.umk.mat.imare.reco.Note;
import pl.umk.mat.imare.reco.Sonst;
import pl.umk.mat.imare.reco.StaveData;
import pl.umk.mat.imare.reco.Tonality;
import pl.umk.mat.imare.reco.Tonality.ClefKey;

/**
 *
 * @author morti
 */
public class StavePanel extends javax.swing.JPanel {

	private enum PaintState {
		PAINT_NORMAL,
		PAINT_PARTS
	};

	private boolean modifyingNotes = false;
	private PaintState paintState = PaintState.PAINT_NORMAL;
	private boolean noteVolumeAlphaBlending = true;

	private int marginTop = 20;
	private int lineSpacing = 8; // staff line spacing
	private int staveSpacing = 30; // spacing between staves
	private int pixelsPerWholeNote = 500;
    private int xStartDrawing = 70; // where starts the note drawing

	private BufferedImage[] noteImages = null;
	private BufferedImage hashImage = null;
	private BufferedImage flatImage = null;
	private BufferedImage naturalImage = null;
	private BufferedImage dotImage = null;
	private BufferedImage trebleClef = null;
	private BufferedImage bassClef = null;

	private StaveData staveData = null; 
	private Vector<StaveNoteData> topNotes = null;
	private Vector<StaveNoteData> bottomNotes = null;
	private Note lastNote = null;
	private int topHeight = 0; // top staff height
	private int bottomHeight = 0; // bottom staff height
	private int topStaffPos = 0; // top staff only position
	private int bottomStaffPos = 0; // bottom staff only position

	/*
	 * Here is the meaning of most of above integer variables:
	 * 
	 * ----------------------- <- top staff space begin
	 * ^				^
	 * | topHeight		| topStaffPos
	 * |				v
	 * | ============================== <- drawn staff
	 * |
	 * v
	 * ----------------------- <- top staff space end
	 * ^
	 * |staveSpacing
	 * v
	 * ----------------------- <- bottom staff space begin
	 * ^				^
	 * | bottomHeight	| bottomStaffPos
	 * |				v
	 * | ============================== <- drawn staff
	 * |
	 * v
	 * ----------------------- <- bottom staff space end
	 */

	/** Creates new form StavePanel */
	public StavePanel() {
		initComponents();
		try {
                    noteImages = new BufferedImage [6];


                    noteImages[0] = ImageIO.read(getClass().getResource("/pl/umk/mat/imare/gui/gfx/nuty/cala.png"));
                    noteImages[1] = ImageIO.read(getClass().getResource("/pl/umk/mat/imare/gui/gfx/nuty/polnuta.png"));
                    noteImages[2] = ImageIO.read(getClass().getResource("/pl/umk/mat/imare/gui/gfx/nuty/cwiercnuta.png"));
                    noteImages[3] = ImageIO.read(getClass().getResource("/pl/umk/mat/imare/gui/gfx/nuty/osemka.png"));
                    noteImages[4] = ImageIO.read(getClass().getResource("/pl/umk/mat/imare/gui/gfx/nuty/szesnastka.png"));
					
                    hashImage = ImageIO.read(getClass().getResource("/pl/umk/mat/imare/gui/gfx/nuty/krzyzyk.png"));
					flatImage = ImageIO.read(getClass().getResource("/pl/umk/mat/imare/gui/gfx/nuty/flat.png"));
					naturalImage = ImageIO.read(getClass().getResource("/pl/umk/mat/imare/gui/gfx/nuty/natural.png"));

					trebleClef = ImageIO.read(getClass().getResource("/pl/umk/mat/imare/gui/gfx/nuty/treble_clef.png"));
					bassClef = ImageIO.read(getClass().getResource("/pl/umk/mat/imare/gui/gfx/nuty/bassclef.png"));
		} catch (IOException ex) {
			Logger.getLogger(StavePanel.class.getName()).log(Level.SEVERE, null, ex);
		}
	}

	/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(255, 255, 255));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 355, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 204, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

	@Override
	public void paint(Graphics g) {
		super.paint(g);
		if(staveData == null) return;

		float totalHeight = 
				(topNotes != null ? topHeight : 0) +
				(bottomNotes != null ? bottomHeight : 0) +
				staveSpacing;
		
		int topStaff = topStaffPos; //(int) (totalHeight / 4 - staffHalf) + 30;
		int bottomStaff = topHeight + bottomStaffPos;//(int) (3 * totalHeight / 4 - staffHalf) + 30;

//		g.setColor(Color.red);
//		g.fillRect(0, 0, getWidth(), topHeight);
//		g.setColor(Color.yellow);
//		g.fillRect(0, topHeight, getWidth(), bottomHeight);
		
		int startDrawing;
		if(paintState == PaintState.PAINT_PARTS) {
			Rectangle r = g.getClipBounds();
			startDrawing = (int) ((r.getHeight() - totalHeight) / 2);
		}
		else
			startDrawing = (int) ((getHeight() - totalHeight) / 2);


		if(topNotes != null) {
			if(startDrawing > 0) topStaff += startDrawing;			
			paintStave(topNotes, trebleClef, topStaff, g);
			paintTrebleClefSigns(topStaff, g);
			if(!modifyingNotes) paintNotes(topNotes, topStaff, g);
		}

		if(bottomNotes != null) {
			if(startDrawing > 0) bottomStaff += startDrawing;			
			paintStave(bottomNotes, bassClef, bottomStaff, g);
			paintBassClefSigns(bottomStaff, g);
			if(!modifyingNotes) paintNotes(bottomNotes, bottomStaff, g);
		}
	}

	private void paintStave(List<StaveNoteData> notes, BufferedImage clef, int y, Graphics g) {

		g.setColor(Color.GRAY);
		for (int i = 0; i < 5; i++) {
			g.drawLine(0, y + i * lineSpacing, getWidth(), y + i * lineSpacing);
		}

		Rectangle clip = g.getClipBounds();
		
		// draw additional lines for notes above or under the staff
		int baseC4 = y + 5 * lineSpacing;
		Iterator<StaveNoteData> noteIter = notes.iterator();
		//for(StaveNoteData n : notes) {
		while(noteIter.hasNext()) {
			StaveNoteData n;
			try {
				n = noteIter.next();
			} catch(ConcurrentModificationException e) {
				return;
			}
			
			BufferedImage noteImage = noteImages[n.note.getType()];
			int signWidth = 0;
			int signPos = 0;
			int nx = n.x;
			switch(n.sign) {
				case SHARP:
					signPos = -10;
					signWidth = 10;
					break;

				case NATURAL:
					signPos = -8;
					signWidth = 8;
					break;

				case FLAT:
					signPos = -8;
					signWidth = 8;
					break;
			}

			Rectangle noteRect = new Rectangle(
					n.x + signPos,	n.y, // pos
					noteImage.getWidth()+ signWidth + n.note.getDots() * 3, // width
					noteImage.getHeight()); // height
			
			if(paintState == PaintState.PAINT_NORMAL) {
//				if(!(clip.x < noteRect.x + noteRect.width &&
//					clip.x + clip.width > noteRect.x)) continue;
			}
			else if(paintState == PaintState.PAINT_PARTS) {
				int noteHalfWidth = noteRect.width / 2;
				int noteXCenter = noteRect.x + noteHalfWidth;

				int tmp = clip.x - noteRect.x;
				if(clip.x < noteRect.x + noteRect.width &&
						clip.x > noteRect.x) {

					if(tmp > noteHalfWidth) {
						nx += clip.x - noteRect.x;
					} else continue;
				}
				else if(clip.x + clip.width < noteRect.x + noteRect.width &&
						clip.x + clip.width > noteRect.x) {

					if(clip.x + clip.width - noteRect.x + noteRect.width < noteHalfWidth) {
						nx -= clip.x + clip.width - noteRect.x + noteRect.width;
					} else continue;
				}
			}

			if(n.y <= 0) {
				for(int liney=0; liney >= n.y; liney -= lineSpacing) {
					g.drawLine(nx - 5, baseC4 - liney, nx+15, baseC4 - liney);
				}
			}
			else if(n.y >= 6*lineSpacing) {
				for(int liney=6*lineSpacing; liney <= n.y; liney += lineSpacing) {
					g.drawLine(nx - 5, baseC4 - liney, nx+15, baseC4 - liney);
				}
			}
		}

		g.drawImage(clef, 5, y + (lineSpacing*4-clef.getHeight())/2 - 3, null);		
	}

	private void paintTrebleClefSigns(int y, Graphics g) {
		ClefKey[] keys = staveData.getTonality().clefSigns();

		int baseC4 = y + 5 * lineSpacing;
		int x = 0;
		int ycorrection = 0;
		for(ClefKey key : keys) {
			BufferedImage sign = null;
			switch(key.sign) {
				case FLAT: sign = flatImage; ycorrection = 13; break;
				case SHARP: sign = hashImage; ycorrection = 9; break;
				case NONE: continue;
			}

//			System.out.println("Bass Level: " + sp.level + " Sign: " + sp.sign);
			g.drawImage(sign, 35 + x, baseC4 - (int)((key.levelTreble)*lineSpacing*0.5) - ycorrection, this);
			x+=10;
		}
	}

	private void paintBassClefSigns(int y, Graphics g) {
		ClefKey[] keys = staveData.getTonality().clefSigns();

		int baseC4 = y + 5 * lineSpacing;
		int x = 0;
		int ycorrection = 0;
		for(ClefKey key : keys) {
			BufferedImage sign = null;
			switch(key.sign) {
				case FLAT: sign = flatImage; ycorrection = 13; break;
				case SHARP: sign = hashImage; ycorrection = 9; break;
				case NONE: continue;
			}

//			System.out.println("Bass Level: " + sp.level + " Sign: " + sp.sign);			
			g.drawImage(sign, 35 + x, baseC4 - (int)((key.levelBass)*lineSpacing*0.5) - ycorrection, this);
			x+=10;
		}
	}

	private void paintNotes(List<StaveNoteData> notes, int y, Graphics g) {
		
		y += 5 * lineSpacing;

		Graphics2D graph = (Graphics2D)g;
		Rectangle clip = g.getClipBounds();

		Iterator<StaveNoteData> noteIter = notes.iterator();
//		for(StaveNoteData n : notes) {
		while(noteIter.hasNext()) {
			StaveNoteData n = null;
			try{
				n = noteIter.next();
			} catch (ConcurrentModificationException ex) {
				return;
			}

			BufferedImage noteImage = noteImages[n.note.getType()];
			int signWidth = 0;
			int signPos = 0;
			int nx = n.x;
			switch(n.sign) {
				case SHARP:
					signPos = -10;
					signWidth = 10;
					break;

				case NATURAL:
					signPos = -8;
					signWidth = 8;
					break;

				case FLAT:
					signPos = -8;
					signWidth = 8;
					break;
			}
			
			Rectangle noteRect = new Rectangle(
					n.x + signPos,	n.y, // pos
					noteImage.getWidth()+ signWidth + n.note.getDots() * 3, // width
					noteImage.getHeight()); // height

			// does note has to be drawn?
//			if(!clip.intersects(noteRect)) continue;
			if(paintState == PaintState.PAINT_NORMAL) {
				if(!(clip.x < noteRect.x + noteRect.width &&
					clip.x + clip.width > noteRect.x)) continue;
			}
			else if(paintState == PaintState.PAINT_PARTS) {
				int noteHalfWidth = noteRect.width / 2;
				int noteXCenter = noteRect.x + noteHalfWidth;

				int tmp = clip.x - noteRect.x;
				if(clip.x < noteRect.x + noteRect.width &&
						clip.x > noteRect.x) {

					if(tmp > noteHalfWidth) {
						nx += clip.x - noteRect.x;
					} else continue;
				}
				else if(clip.x + clip.width < noteRect.x + noteRect.width &&
						clip.x + clip.width > noteRect.x) {

					if(clip.x + clip.width - noteRect.x + noteRect.width < noteHalfWidth) {
						nx -= clip.x + clip.width - noteRect.x + noteRect.width;
					} else continue;
				}
			}


			// transparency
			BufferedImageOp alphaOp = null;
			float alpha = 1.0f;
			if (noteVolumeAlphaBlending) {
				// alpha blending stuff
				alpha = (float)(n.note.getVolume()) / 127.f;
				float scales[] = { 0, 0, 0, alpha};
				float offsets[] = { 0, 0, 0, 0};
				alphaOp = new RescaleOp(scales, offsets, null);
			}

			// drawing stuff
			graph.drawImage(noteImages[n.note.getType()], alphaOp, nx, y - n.y - 26);

			switch(n.sign) {
				case FLAT:
					graph.drawImage(flatImage, alphaOp, nx - 8, y - n.y - 14);
					break;

				case NATURAL:
					graph.drawImage(naturalImage, alphaOp, nx - 8, y - n.y - 10);
					break;

				case SHARP:
					graph.drawImage(hashImage, alphaOp, nx - 10, y - n.y - 9);
					break;
			}
//			if(n.sign == Tonality.Sign.FLAT) {
//
//			}
//			else(n.)
//			if(n.note.isHashed()) {
//				graph.drawImage(hashImage, alphaOp, nx - 10, y - n.y - 9);
//			}


			for(int i=0; i < n.note.getDots(); i++) {
				graph.setColor(new Color(0,0,0, alpha));
				graph.fillOval(nx + 12 + i*4, y - (n.y + 3), 3, 3);
			}
		}
	}

	public void setStaveData(StaveData staveData) {
		this.staveData = staveData;
		if(staveData == null) {
			topNotes = null;
			bottomNotes = null;
			lastNote = null;
			EventQueue.invokeLater(new Runnable() {
				@Override
				public void run() {
					setSize(xStartDrawing, getHeight());
				}
			});
			
			return;
		}
		modifyingNotes = true;		

		Tonality tonality = staveData.getTonality();
		xStartDrawing = tonality.clefSigns().length*10 + 40;

		int staveLength = 0;
		int miny = 0, maxy = 0;
		Note last = new Note();
		last.setOffset(0);

		// top staff
		if(staveData.top != null) {
			ArrayList<Note> top = staveData.top;
			topNotes = new Vector<StaveNoteData>(top.size());
			for(Note n : top) {
				StaveNoteData d = new StaveNoteData();
				d.note = n;
				int field;
				if(tonality != null) {
					Tonality.StaffPitch staffPitch = tonality.adapt(n);
					field = staffPitch.level;
					d.sign = staffPitch.sign;
				}
				else {
//					field = getNoteField(n.getPitch());
//					d.sign = n.isHashed() ? Tonality.Sign.SHARP : Tonality.Sign.NONE;
					field = 0;
					d.sign = Tonality.Sign.NONE;
				}


				d.x = (int) (pixelsPerWholeNote * n.getOffset()) + xStartDrawing;
				d.y = (int)(field * lineSpacing * 0.5);
				topNotes.add(d);

				if(staveLength < d.x) staveLength = d.x;
				if(miny > d.y) miny = d.y;
				if(maxy < d.y) maxy = d.y;

				if(last.getOffset()<n.getOffset()){
					last = n;
				}
			}

			topHeight = maxy - miny + noteImages[0].getHeight() + 3*lineSpacing;
			if(topHeight < 6*lineSpacing) topHeight = 6*lineSpacing;

			topStaffPos = maxy + lineSpacing;
		}
		else {
			topHeight = 0;
			topNotes = null;
		}

		miny = 0;
		maxy = 0;

		// bottom staff
		if(staveData.bottom != null) {
			ArrayList<Note> bottom = staveData.bottom;
			bottomNotes = new Vector<StaveNoteData>(bottom.size());
			for(Note n : bottom) {
				StaveNoteData d = new StaveNoteData();
				d.note = n;

				int field;
				if(tonality != null) {
					Tonality.StaffPitch staffPitch = tonality.adapt(n);
					field = staffPitch.level + 12;
					d.sign = staffPitch.sign;
				}
				else {
//					field = getNoteField(n.getPitch());
//					d.sign = n.isHashed() ? Tonality.Sign.SHARP : Tonality.Sign.NONE;
					field = 0;
					d.sign = Tonality.Sign.NONE;
				}

				d.x = (int) (pixelsPerWholeNote * n.getOffset()) + xStartDrawing;
				d.y = (int)(field * lineSpacing * 0.5);
				bottomNotes.add(d);

				if(staveLength < d.x) staveLength = d.x;
				if(miny > d.y) miny = d.y;
				if(maxy < d.y) maxy = d.y;

				if(last.getOffset()<n.getOffset()){
					last = n;
				}
			}

			bottomHeight = maxy - miny + noteImages[0].getHeight() + 3*lineSpacing;
			if(bottomHeight < 6*lineSpacing) bottomHeight = 6*lineSpacing;

			bottomStaffPos = maxy + lineSpacing;
		}
		else {
			bottomHeight = 0;
			bottomNotes = null;
		}

		lastNote = last;
		if(last.getOffset() > 0)
                    staveLength += last.getDuration()*pixelsPerWholeNote + xStartDrawing;
		modifyingNotes = false;

		final int len = staveLength;
		EventQueue.invokeLater(new Runnable() {
			@Override
			public void run() {
//				setSize(len, topHeight + bottomHeight);
//				setPreferredSize(new Dimension(len, topHeight + bottomHeight));
				setSize(len, getHeight());
				setPreferredSize(new Dimension(len, getHeight()));
				repaint();
			}
		});
	}

	public StaveData getStaveData() {
		return staveData;
	}



    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

	private class StaveNoteData {
		int x;
		int y;
//		int sign; // -1 - bemol; 1 - krzyzyk; 0 - nic
		Tonality.Sign sign;

		Note note;
	};

	public boolean isNoteVolumeAlphaBlending() {
		return noteVolumeAlphaBlending;
	}

	public void setNoteVolumeAlphaBlending(boolean noteVolumeAlphaBlending) {
		this.noteVolumeAlphaBlending = noteVolumeAlphaBlending;
		repaint();
	}

	public int getStartPosition(){
		return xStartDrawing;
	}

	public int getPixelsPerWholeNote(){
		return pixelsPerWholeNote;
	}

	@Override
	public void print(Graphics g) {
		paintState = PaintState.PAINT_PARTS;
		paint(g);
		paintState = PaintState.PAINT_NORMAL;
	}

	public int getTotalHeight() {
		return (int)
				(topNotes != null ? topHeight : 0) +
				(bottomNotes != null ? bottomHeight : 0) +
				staveSpacing;
	}

	public void addNote(Note n) {
		modifyingNotes = true;
		if(staveData == null) {
			staveData = new StaveData();
			topHeight = bottomHeight = 6 * lineSpacing;
		}

		StaveNoteData d = new StaveNoteData();
		Tonality tonality = staveData.getTonality();

		d.note = n;
		int field;
		if(tonality != null) {
			Tonality.StaffPitch staffPitch = tonality.adapt(n);
			field = staffPitch.level;
			d.sign = staffPitch.sign;

			if(n.getPitch() < Sonst.TOP_STAFF_LOW_PITCH_BOUND) {
				field += 12; // dla dolnej pieciolini przenosimy do gory
			}
		}
		else {
			field = 0;
			d.sign = Tonality.Sign.NONE;
		}


		d.x = (int) (pixelsPerWholeNote * n.getOffset()) + xStartDrawing;
		d.y = (int)(field * lineSpacing * 0.5);

		if(n.getPitch() >= Sonst.TOP_STAFF_LOW_PITCH_BOUND) {
			if(topNotes == null) topNotes = new Vector<StaveNoteData>();
			staveData.top.add(n);
			topNotes.add(d);
		} else {
			if(bottomNotes == null) bottomNotes = new Vector<StaveNoteData>();

			staveData.bottom.add(n);
			bottomNotes.add(d);
		}



		if(lastNote == null || lastNote.getOffset() < n.getOffset())
			lastNote = n;

		Dimension size = getSize();
//		int noteLenPix = (int)(n.getDuration() * pixelsPerWholeNote);
//		int offset = (d.x + noteLenPix) - size.width;
//		if(offset > 0) size.width += offset;
		int nWidth = (int)((lastNote.getOffset()+lastNote.getDuration()) * pixelsPerWholeNote) + xStartDrawing;

		if(size.width < nWidth) size.width = nWidth;

		setSize(size);
//		setPreferredSize(size);

		modifyingNotes = false;		
		revalidate();
		repaint();
	}
}
